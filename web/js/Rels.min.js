/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by victor on 9/8/15.
	 */

	'use strict';

	var _SearchJs = __webpack_require__(1);

	var objectAssign = __webpack_require__(2);
	var Mustache = __webpack_require__(3);

	var DB;
	var schemaBuilder = lf.schema.create('searchHistory', 1);
	var initDB = function initDB() {
	    schemaBuilder.createTable('History').addColumn('id', lf.Type.INTEGER).addColumn('from', lf.Type.OBJECT).addColumn('to', lf.Type.OBJECT).addColumn('useCount', lf.Type.INTEGER).addPrimaryKey(['id']).addIndex('idxDeadline', ['useCount'], false, lf.Order.DESC);
	};

	initDB();
	schemaBuilder.connect().then(function (db) {
	    DB = db;
	    loadHistory();
	});

	var loadHistory = function loadHistory() {
	    var h = DB.getSchema().table('History');
	    console.log(h);
	    DB.select().from(h).orderBy(h.useCount, lf.Order.DESC)
	    //.where(lf.op.and(h.from.eq(sites.from), h.to.eq(sites.to)))
	    .exec().then(function (rows) {
	        var view = document.createElement('div');
	        rows.forEach(function (r) {
	            console.log(r);
	            var hRow = document.createElement('div');
	            hRow.innerHTML = r.from.Name + ' -> ' + r.to.Name;
	            hRow.className = 'history-row';
	            hRow.onclick = function () {
	                _from.value = r.from.Name;
	                _to.value = r.to.Name;

	                sites.from = r.from;
	                sites.to = r.to;
	                submitButtonAction(null);
	            };
	            view.appendChild(hRow);
	        });

	        history.appendChild(view);
	    });
	};

	var encodeData = function encodeData(data) {
	    var urlEncodedDataPairs = [];
	    for (var name in data) {
	        urlEncodedDataPairs.push(encodeURIComponent(name) + '=' + encodeURIComponent(data[name]));
	    }
	    return urlEncodedDataPairs.join('&').replace(/%20/g, '+');
	};

	var typeIcon = function typeIcon(leg) {
	    var bbus = /blåbuss/;
	    var bus = /buss/;

	    var tubg = /tunnelbanans gröna/;
	    var tubb = /tunnelbanans blå/;
	    var tubr = /tunnelbanans röda/;

	    if (bbus.test(leg.name)) {
	        return 'BUS_blue';
	    } else if (bus.test(leg.name)) {
	        return 'BUS_red';
	    } else if (tubr.test(leg.name)) {
	        return 'MET_red';
	    } else if (tubb.test(leg.name)) {
	        return 'MET_blue';
	    } else if (tubg.test(leg.name)) {
	        return 'MET_green';
	    } else {
	        return ({
	            'TRAIN': 'TRN',
	            'BUS': 'BUS_red',
	            'WALK': 'Walk',
	            'METRO': 'MET',
	            'TRAM': 'TRL'
	        })[leg.type];
	    }
	};

	window.sites = {};
	var rootSearch = document.querySelector('#rootSearch');
	var root = document.querySelector('#root');
	var spinner = document.createElement('div');
	var history = document.querySelector('#history');
	var resultView = null;
	var currentForm = null;
	var prevDate = null,
	    nextDate = null;
	spinner.innerHTML = '<div class="spinner"><div class="cube1"></div><div class="cube2"></div></div><div class="load-text">Väntar på SL..</div>';

	// form fields
	var day = document.querySelector('#day');
	var radios = document.getElementsByName('timeSet');
	var time = document.querySelector('#time');
	var _from = document.querySelector('#from');
	var _to = document.querySelector('#to');

	var prevButton = document.createElement('button');
	prevButton.innerHTML = Translator.trans('Tidigare');
	prevButton.className = 'btn btn-default btn-block';
	var nextButton = document.createElement('button');
	nextButton.innerHTML = Translator.trans('Senare');
	nextButton.className = 'btn btn-default btn-block';

	var prevTrips = function prevTrips(e) {
	    e.preventDefault();

	    if (prevDate === null) {
	        prevDate = currentForm.day + " " + currentForm.time;
	    }

	    var m = moment(prevDate, "YYYY-MM-DD HH:mm");
	    m.subtract(120, 'minutes');
	    prevDate = m.format('YYYY-MM-DD HH:mm');

	    var args = {};
	    objectAssign(args, currentForm);
	    args.day = m.format('YYYY-MM-DD');
	    args.time = m.format('HH:mm');
	    console.log(args);
	    queryTrip(args, true);
	};
	prevButton.onclick = prevTrips;

	var nextTrips = function nextTrips(e) {
	    e.preventDefault();

	    if (nextDate === null) {
	        nextDate = currentForm.day + " " + currentForm.time;
	    }

	    var m = moment(nextDate, "YYYY-MM-DD HH:mm");
	    m.add(120, 'minutes');
	    nextDate = m.format('YYYY-MM-DD HH:mm');

	    var args = {};
	    objectAssign(args, currentForm);
	    args.day = m.format('YYYY-MM-DD');
	    args.time = m.format('HH:mm');
	    console.log(args);
	    queryTrip(args, false, true);
	};
	nextButton.onclick = nextTrips;

	/**
	 * Init the results area, ie. put the big from over to the left and create a new box for results
	 */
	var initSearchArea = function initSearchArea() {
	    var box = document.querySelector('#box');
	    box.className = 'col-md-4';
	    resultView = document.createElement('div');
	    resultView.className = 'col-md-8';
	    box.parentNode.appendChild(resultView);
	};

	var parseForm = function parseForm() {

	    var arrival = '';
	    Array.prototype.forEach.call(radios, function (r) {
	        if (r.checked) {
	            arrival = r.value;
	        }
	    });

	    return {
	        from: sites.from.SiteId,
	        to: sites.to.SiteId,
	        day: day.value,
	        time: time.value,
	        arrival: arrival
	    };
	};

	window.startFromUrl = function (toId, toName, fromId, fromName) {
	    sites.to = {
	        SiteId: toId,
	        Name: toName
	    };
	    sites.from = {
	        SiteId: fromId,
	        Name: fromName
	    };
	    _to.value = toName;
	    _from.value = fromName;

	    submitButtonAction(null);
	};

	/**
	 * Form submit action
	 * @param event
	 */
	var submitButtonAction = function submitButtonAction(event) {
	    event === null || event.preventDefault();
	    if (resultView === null) {
	        initSearchArea();
	    }

	    resultView.innerHTML = '';

	    var resultHead = document.createElement('h3');
	    resultHead.className = 'text-center';
	    resultHead.innerHTML = sites.from.Name + ' -> ' + sites.to.Name;
	    resultView.appendChild(resultHead);
	    resultView.appendChild(spinner);
	    //resultView.appendChild(resultListContainer);
	    //resultListContainer.innerHTML = '';
	    spinner.style.display = 'block';

	    var formInput = parseForm();
	    currentForm = formInput;

	    var urlBits = [Translator.locale, sites.from.SiteId, sites.to.SiteId, encodeURIComponent(sites.from.Name), encodeURIComponent(sites.to.Name)];
	    var hist = urlBits.join('/');

	    window.history.pushState(null, 'Räls - ' + sites.from.Name + ' -> ' + sites.to.Name, window.location.origin + '/' + hist);

	    nextDate = null;
	    prevDate = null;

	    queryTrip(formInput);

	    if (DB === undefined) return;
	    var h = DB.getSchema().table('History');
	    console.log(h);
	    DB.select().from(h)
	    //.where(lf.op.and(h.from.eq(sites.from), h.to.eq(sites.to)))
	    .exec().then(function (rows) {
	        var exists = null;

	        // working around .eq beeing undefined in the query
	        rows.forEach(function (r) {
	            //console.log(r);
	            if (r.to.SiteId === sites.to.SiteId && r.from.SiteId === sites.from.SiteId) exists = r;
	        });

	        console.log('query result');
	        //console.log(rows);

	        if (exists === null) {
	            console.log('new history');
	            var row = h.createRow({
	                'id': parseInt(sites.from.SiteId + '' + sites.to.SiteId),
	                'from': sites.from,
	                'to': sites.to,
	                'useCount': 1
	            });
	            DB.insertOrReplace().into(h).values([row]).exec();
	        } else {
	            console.log('update history');
	            //var r = exists;
	            exists.useCount++;
	            console.log(exists);
	            var row = h.createRow(exists);
	            console.log(row);
	            DB.insertOrReplace().into(h).values([row]).exec();
	        }
	    });
	};

	var queryTrip = function queryTrip(params) {
	    var appendTop = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	    var appendBottom = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

	    fetch('/api/trip?' + encodeData(params), {
	        credentials: 'include'
	    }).then(function (res) {
	        return res.json();
	    }).then(function (res) {
	        return renderResults(res, appendTop, appendBottom);
	    });
	};

	/**
	 * Render search results
	 * @param resp
	 * @param appendBottom
	 * @param appendTop
	 */
	var renderResults = function renderResults(resp, appendTop, appendBottom) {
	    console.log(resp);
	    var resultList = document.createElement('div');

	    if (resp.TripList.errorText !== undefined) {
	        resultList.innerHTML = '<p class="error">' + resp.TripList.errorText + '</p>';
	        resultList.className = 'alert alert-danger';
	        spinner.style.display = 'none';
	        resultView.appendChild(resultList);
	        return;
	    }

	    var trips = resp.TripList.Trip;

	    trips.forEach(function (t) {
	        console.log(t);
	        // legs may be an Array or a Object, because SL
	        var legs = t.LegList.Leg;

	        var legsView = '';
	        var legsViewShort = '';

	        var legViewTemplate = "<div><div>- {{leg.Origin.time}} {{leg.Origin.name}}</div> <div><i class='icon icon-{{icon}}'></i> {{leg.name}} {{leg.dir}}</div> <div>- {{leg.Destination.time}} {{leg.Destination.name}}</div></div><hr>";
	        var legViewShortTemplate = "<div class='short-leg'><i class='icon icon-{{icon}}'></i>{{leg.line}}</div>";

	        var from, to;
	        var geoRefs = [];
	        if (Array.isArray(legs)) {
	            //console.log(legs);
	            legs.forEach(function (leg) {
	                //console.log(leg);
	                legsView += Mustache.render(legViewTemplate, { leg: leg, icon: typeIcon(leg) });
	                legsViewShort += Mustache.render(legViewShortTemplate, {
	                    icon: typeIcon(leg),
	                    leg: leg
	                });

	                if (leg.type !== 'WALK') geoRefs.push(leg.GeometryRef.ref.substring(6));
	            });

	            from = legs[0].Origin;
	            to = legs[legs.length - 1].Destination;
	        } else {
	            legsView += Mustache.render(legViewTemplate, { leg: legs, icon: typeIcon(legs) });
	            legsViewShort += Mustache.render(legViewShortTemplate, {
	                icon: typeIcon(legs),
	                leg: legs
	            });

	            from = legs.Origin;
	            to = legs.Destination;
	            if (legs.type !== 'WALK') geoRefs.push(legs.GeometryRef.ref.substring(6));
	        }

	        var now = from.date + " " + from.time;
	        var then = to.date + " " + to.time;

	        var ms = moment(then, "YYYY-MM-DD HH:mm").diff(moment(now, "YYYY-MM-DD HH:mm"));
	        var d = moment.duration(ms);
	        var s = Math.floor(d.asHours()) + moment.utc(ms).format(":mm:ss");

	        var listItem = document.createElement('div');

	        // action buttons
	        var listItemButtons = document.createElement('div');
	        var routeButton = document.createElement('button');
	        routeButton.className = 'btn btn-default btn-detail';
	        routeButton.innerHTML = Translator.trans('Resväg');
	        var mapButton = document.createElement('button');
	        mapButton.className = 'btn btn-default btn-detail';
	        mapButton.innerHTML = Translator.trans('Karta');
	        listItemButtons.appendChild(routeButton);
	        listItemButtons.appendChild(mapButton);

	        // wrapper box
	        var listItemBox = document.createElement('div');
	        listItemBox.style.display = 'none';

	        // list items
	        var listItemDetail = document.createElement('div');
	        listItemDetail.className = 'trip-detail';
	        listItemDetail.innerHTML = legsView;

	        listItemBox.appendChild(listItemDetail);

	        listItem.className = 'trip';

	        var listItemHeader = document.createElement('div');
	        listItemHeader.innerHTML = Mustache.render("<h3>{{from.time}} -> {{to.time}} ({{duration}})</h3> <div class='short'>{{{legsShort}}}</div>", {
	            legsShort: legsViewShort,
	            trip: t,
	            from: from,
	            to: to,
	            duration: s
	        });
	        listItem.appendChild(listItemHeader);
	        listItem.appendChild(listItemBox);

	        listItemHeader.onclick = function (e) {
	            if (listItemBox.style.display !== 'block') {
	                listItemBox.style.display = 'block';
	            } else {
	                listItemBox.style.display = 'none';
	            }
	        };
	        resultList.appendChild(listItem);

	        var listItemMap = document.createElement('div');
	        var mapId = 'map_' + Math.random().toString(36).substr(2, 7);
	        listItemMap.id = mapId;
	        listItemMap.className = 'trip-map';

	        listItemBox.appendChild(listItemMap);
	        listItemBox.appendChild(listItemButtons);
	        mapButton.onclick = function (e) {
	            listItemDetail.style.display = 'none';
	            listItemMap.style.display = 'block';
	            renderMap(mapId, geoRefs);
	        };

	        routeButton.onclick = function (e) {
	            listItemMap.style.display = 'none';
	            listItemDetail.style.display = 'block';
	        };
	    });
	    spinner.style.display = 'none';
	    console.log(resultList);

	    if (appendTop) {
	        prevButton.parentNode.insertBefore(resultList, prevButton.parentNode.childNodes[3]);
	    } else if (appendBottom) {
	        nextButton.parentNode.insertBefore(resultList, nextButton.parentNode.childNodes[nextButton.parentNode.childNodes.length - 1]);
	    } else {
	        resultView.appendChild(prevButton);
	        resultView.appendChild(resultList);
	        resultView.appendChild(nextButton);
	    }
	};

	var renderMap = function renderMap(mapId, geoRefs) {
	    //console.log(geoRefs);
	    try {
	        L.mapbox.accessToken = 'pk.eyJ1IjoiYXRyaWl4IiwiYSI6IjdmNmY1MmUwZjY1ZDJmM2RlNDE0OGU3NmIyZDU2YWJmIn0.7rJekXMaz4HjJRNkgHF1nw';

	        var map = L.mapbox.map(mapId, 'atriix.nd49o5jk');

	        //var map = L.map(mapId).setView([59.3282702,18.065956], 13);
	        L.control.layers({
	            'Streets': L.mapbox.tileLayer('mapbox.mapbox-streets-v6').addTo(map),
	            'Satellite': L.mapbox.tileLayer('mapbox.satellite')
	        }, //'Miao': L.mapbox.tileLayer('mapbox.mapbox-streets-v6')
	        {
	            'Bike Stations': L.mapbox.tileLayer('examples.bike-locations'),
	            'Bike Lanes': L.mapbox.tileLayer('examples.bike-lanes')
	        }).addTo(map);
	        //L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
	        //    attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
	        //    maxZoom: 18,
	        //    id: 'atriix.nd49o5jk',
	        //    accessToken: 'pk.eyJ1IjoiYXRyaWl4IiwiYSI6IjdmNmY1MmUwZjY1ZDJmM2RlNDE0OGU3NmIyZDU2YWJmIn0.7rJekXMaz4HjJRNkgHF1nw'
	        //}).addTo(map);

	        var allPoints = [];
	        geoRefs.forEach(function (ref) {
	            fetch('/api/geometry?ref=' + ref).then(function (res) {
	                return res.json();
	            }).then(function (res) {
	                var points = res.Geometry.Points.Point;

	                var pointList = points.map(function (p) {
	                    return new L.LatLng(p.lat, p.lon);
	                });
	                allPoints.push(pointList);

	                var polyline = new L.Polyline(pointList, {
	                    color: 'red',
	                    weight: 3,
	                    opacity: 0.5,
	                    smoothFactor: 1

	                });
	                polyline.addTo(map);

	                var bounds = new L.LatLngBounds(allPoints);
	                map.fitBounds(bounds);
	            });
	        });
	    } catch (e) {}
	};

	rootSearch.onsubmit = submitButtonAction;

	var makeComplete = function makeComplete(query, syncResults, asyncResults) {
	    console.log(query);

	    var head = new Headers();
	    //head.append('x-token', '{{ csrf_token('api_place') }}');

	    fetch('/api/place?query=' + query, {
	        headers: head,
	        credentials: 'include'
	    }).then(function (resp) {
	        return resp.json();
	    }).then(function (resp) {
	        asyncResults(resp);
	    });
	};
	var from = $('.typeahead');
	from.typeahead({
	    minLength: 2,
	    highlight: false
	}, {
	    source: makeComplete,
	    templates: {
	        suggestion: function suggestion(data) {
	            return '<div>' + data.Name + '</div>';
	        }
	    },
	    display: 'Name'
	});
	from.on('typeahead:select', function (e, data) {
	    console.log(e);
	    console.log(data);
	    if (e.target.id === 'from') {
	        sites.from = data;
	    } else if (e.target.id === 'to') {
	        sites.to = data;
	    }
	});

/***/ },
/* 1 */
/***/ function(module, exports) {

	/**
	 * Created by victor on 9/8/15.
	 */

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var Search = (function () {
	    var vm = {};
	    var api = {};

	    vm.init = function () {};

	    api.controller = function () {};

	    api.view = function () {
	        return React.createElement("div", null);
	    };

	    return api;
	})();
	exports.Search = Search;

/***/ },
/* 2 */
/***/ function(module, exports) {

	/* eslint-disable no-unused-vars */
	'use strict';
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	module.exports = Object.assign || function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * mustache.js - Logic-less {{mustache}} templates with JavaScript
	 * http://github.com/janl/mustache.js
	 */

	/*global define: false Mustache: true*/

	'use strict';

	(function defineMustache(global, factory) {
	  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
	    factory(exports); // CommonJS
	  } else if (true) {
	      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else {
	        global.Mustache = {};
	        factory(Mustache); // script, wsh, asp
	      }
	})(undefined, function mustacheFactory(mustache) {

	  var objectToString = Object.prototype.toString;
	  var isArray = Array.isArray || function isArrayPolyfill(object) {
	    return objectToString.call(object) === '[object Array]';
	  };

	  function isFunction(object) {
	    return typeof object === 'function';
	  }

	  /**
	   * More correct typeof string handling array
	   * which normally returns typeof 'object'
	   */
	  function typeStr(obj) {
	    return isArray(obj) ? 'array' : typeof obj;
	  }

	  function escapeRegExp(string) {
	    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
	  }

	  /**
	   * Null safe way of checking whether or not an object,
	   * including its prototype, has a given property
	   */
	  function hasProperty(obj, propName) {
	    return obj != null && typeof obj === 'object' && propName in obj;
	  }

	  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
	  // See https://github.com/janl/mustache.js/issues/189
	  var regExpTest = RegExp.prototype.test;
	  function testRegExp(re, string) {
	    return regExpTest.call(re, string);
	  }

	  var nonSpaceRe = /\S/;
	  function isWhitespace(string) {
	    return !testRegExp(nonSpaceRe, string);
	  }

	  var entityMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;',
	    '/': '&#x2F;'
	  };

	  function escapeHtml(string) {
	    return String(string).replace(/[&<>"'\/]/g, function fromEntityMap(s) {
	      return entityMap[s];
	    });
	  }

	  var whiteRe = /\s*/;
	  var spaceRe = /\s+/;
	  var equalsRe = /\s*=/;
	  var curlyRe = /\s*\}/;
	  var tagRe = /#|\^|\/|>|\{|&|=|!/;

	  /**
	   * Breaks up the given `template` string into a tree of tokens. If the `tags`
	   * argument is given here it must be an array with two string values: the
	   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
	   * course, the default is to use mustaches (i.e. mustache.tags).
	   *
	   * A token is an array with at least 4 elements. The first element is the
	   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
	   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
	   * all text that appears outside a symbol this element is "text".
	   *
	   * The second element of a token is its "value". For mustache tags this is
	   * whatever else was inside the tag besides the opening symbol. For text tokens
	   * this is the text itself.
	   *
	   * The third and fourth elements of the token are the start and end indices,
	   * respectively, of the token in the original template.
	   *
	   * Tokens that are the root node of a subtree contain two more elements: 1) an
	   * array of tokens in the subtree and 2) the index in the original template at
	   * which the closing tag for that section begins.
	   */
	  function parseTemplate(template, tags) {
	    if (!template) return [];

	    var sections = []; // Stack to hold section tokens
	    var tokens = []; // Buffer to hold the tokens
	    var spaces = []; // Indices of whitespace tokens on the current line
	    var hasTag = false; // Is there a {{tag}} on the current line?
	    var nonSpace = false; // Is there a non-space char on the current line?

	    // Strips all whitespace tokens array for the current line
	    // if there was a {{#tag}} on it and otherwise only space.
	    function stripSpace() {
	      if (hasTag && !nonSpace) {
	        while (spaces.length) delete tokens[spaces.pop()];
	      } else {
	        spaces = [];
	      }

	      hasTag = false;
	      nonSpace = false;
	    }

	    var openingTagRe, closingTagRe, closingCurlyRe;
	    function compileTags(tagsToCompile) {
	      if (typeof tagsToCompile === 'string') tagsToCompile = tagsToCompile.split(spaceRe, 2);

	      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2) throw new Error('Invalid tags: ' + tagsToCompile);

	      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
	      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
	      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
	    }

	    compileTags(tags || mustache.tags);

	    var scanner = new Scanner(template);

	    var start, type, value, chr, token, openSection;
	    while (!scanner.eos()) {
	      start = scanner.pos;

	      // Match any text between tags.
	      value = scanner.scanUntil(openingTagRe);

	      if (value) {
	        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
	          chr = value.charAt(i);

	          if (isWhitespace(chr)) {
	            spaces.push(tokens.length);
	          } else {
	            nonSpace = true;
	          }

	          tokens.push(['text', chr, start, start + 1]);
	          start += 1;

	          // Check for whitespace on the current line.
	          if (chr === '\n') stripSpace();
	        }
	      }

	      // Match the opening tag.
	      if (!scanner.scan(openingTagRe)) break;

	      hasTag = true;

	      // Get the tag type.
	      type = scanner.scan(tagRe) || 'name';
	      scanner.scan(whiteRe);

	      // Get the tag value.
	      if (type === '=') {
	        value = scanner.scanUntil(equalsRe);
	        scanner.scan(equalsRe);
	        scanner.scanUntil(closingTagRe);
	      } else if (type === '{') {
	        value = scanner.scanUntil(closingCurlyRe);
	        scanner.scan(curlyRe);
	        scanner.scanUntil(closingTagRe);
	        type = '&';
	      } else {
	        value = scanner.scanUntil(closingTagRe);
	      }

	      // Match the closing tag.
	      if (!scanner.scan(closingTagRe)) throw new Error('Unclosed tag at ' + scanner.pos);

	      token = [type, value, start, scanner.pos];
	      tokens.push(token);

	      if (type === '#' || type === '^') {
	        sections.push(token);
	      } else if (type === '/') {
	        // Check section nesting.
	        openSection = sections.pop();

	        if (!openSection) throw new Error('Unopened section "' + value + '" at ' + start);

	        if (openSection[1] !== value) throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
	      } else if (type === 'name' || type === '{' || type === '&') {
	        nonSpace = true;
	      } else if (type === '=') {
	        // Set the tags for the next time around.
	        compileTags(value);
	      }
	    }

	    // Make sure there are no open sections when we're done.
	    openSection = sections.pop();

	    if (openSection) throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

	    return nestTokens(squashTokens(tokens));
	  }

	  /**
	   * Combines the values of consecutive text tokens in the given `tokens` array
	   * to a single token.
	   */
	  function squashTokens(tokens) {
	    var squashedTokens = [];

	    var token, lastToken;
	    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
	      token = tokens[i];

	      if (token) {
	        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
	          lastToken[1] += token[1];
	          lastToken[3] = token[3];
	        } else {
	          squashedTokens.push(token);
	          lastToken = token;
	        }
	      }
	    }

	    return squashedTokens;
	  }

	  /**
	   * Forms the given array of `tokens` into a nested tree structure where
	   * tokens that represent a section have two additional items: 1) an array of
	   * all tokens that appear in that section and 2) the index in the original
	   * template that represents the end of that section.
	   */
	  function nestTokens(tokens) {
	    var nestedTokens = [];
	    var collector = nestedTokens;
	    var sections = [];

	    var token, section;
	    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
	      token = tokens[i];

	      switch (token[0]) {
	        case '#':
	        case '^':
	          collector.push(token);
	          sections.push(token);
	          collector = token[4] = [];
	          break;
	        case '/':
	          section = sections.pop();
	          section[5] = token[2];
	          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
	          break;
	        default:
	          collector.push(token);
	      }
	    }

	    return nestedTokens;
	  }

	  /**
	   * A simple string scanner that is used by the template parser to find
	   * tokens in template strings.
	   */
	  function Scanner(string) {
	    this.string = string;
	    this.tail = string;
	    this.pos = 0;
	  }

	  /**
	   * Returns `true` if the tail is empty (end of string).
	   */
	  Scanner.prototype.eos = function eos() {
	    return this.tail === '';
	  };

	  /**
	   * Tries to match the given regular expression at the current position.
	   * Returns the matched text if it can match, the empty string otherwise.
	   */
	  Scanner.prototype.scan = function scan(re) {
	    var match = this.tail.match(re);

	    if (!match || match.index !== 0) return '';

	    var string = match[0];

	    this.tail = this.tail.substring(string.length);
	    this.pos += string.length;

	    return string;
	  };

	  /**
	   * Skips all text until the given regular expression can be matched. Returns
	   * the skipped string, which is the entire tail if no match can be made.
	   */
	  Scanner.prototype.scanUntil = function scanUntil(re) {
	    var index = this.tail.search(re),
	        match;

	    switch (index) {
	      case -1:
	        match = this.tail;
	        this.tail = '';
	        break;
	      case 0:
	        match = '';
	        break;
	      default:
	        match = this.tail.substring(0, index);
	        this.tail = this.tail.substring(index);
	    }

	    this.pos += match.length;

	    return match;
	  };

	  /**
	   * Represents a rendering context by wrapping a view object and
	   * maintaining a reference to the parent context.
	   */
	  function Context(view, parentContext) {
	    this.view = view;
	    this.cache = { '.': this.view };
	    this.parent = parentContext;
	  }

	  /**
	   * Creates a new context using the given view with this context
	   * as the parent.
	   */
	  Context.prototype.push = function push(view) {
	    return new Context(view, this);
	  };

	  /**
	   * Returns the value of the given name in this context, traversing
	   * up the context hierarchy if the value is absent in this context's view.
	   */
	  Context.prototype.lookup = function lookup(name) {
	    var cache = this.cache;

	    var value;
	    if (cache.hasOwnProperty(name)) {
	      value = cache[name];
	    } else {
	      var context = this,
	          names,
	          index,
	          lookupHit = false;

	      while (context) {
	        if (name.indexOf('.') > 0) {
	          value = context.view;
	          names = name.split('.');
	          index = 0;

	          /**
	           * Using the dot notion path in `name`, we descend through the
	           * nested objects.
	           *
	           * To be certain that the lookup has been successful, we have to
	           * check if the last object in the path actually has the property
	           * we are looking for. We store the result in `lookupHit`.
	           *
	           * This is specially necessary for when the value has been set to
	           * `undefined` and we want to avoid looking up parent contexts.
	           **/
	          while (value != null && index < names.length) {
	            if (index === names.length - 1) lookupHit = hasProperty(value, names[index]);

	            value = value[names[index++]];
	          }
	        } else {
	          value = context.view[name];
	          lookupHit = hasProperty(context.view, name);
	        }

	        if (lookupHit) break;

	        context = context.parent;
	      }

	      cache[name] = value;
	    }

	    if (isFunction(value)) value = value.call(this.view);

	    return value;
	  };

	  /**
	   * A Writer knows how to take a stream of tokens and render them to a
	   * string, given a context. It also maintains a cache of templates to
	   * avoid the need to parse the same template twice.
	   */
	  function Writer() {
	    this.cache = {};
	  }

	  /**
	   * Clears all cached templates in this writer.
	   */
	  Writer.prototype.clearCache = function clearCache() {
	    this.cache = {};
	  };

	  /**
	   * Parses and caches the given `template` and returns the array of tokens
	   * that is generated from the parse.
	   */
	  Writer.prototype.parse = function parse(template, tags) {
	    var cache = this.cache;
	    var tokens = cache[template];

	    if (tokens == null) tokens = cache[template] = parseTemplate(template, tags);

	    return tokens;
	  };

	  /**
	   * High-level method that is used to render the given `template` with
	   * the given `view`.
	   *
	   * The optional `partials` argument may be an object that contains the
	   * names and templates of partials that are used in the template. It may
	   * also be a function that is used to load partial templates on the fly
	   * that takes a single argument: the name of the partial.
	   */
	  Writer.prototype.render = function render(template, view, partials) {
	    var tokens = this.parse(template);
	    var context = view instanceof Context ? view : new Context(view);
	    return this.renderTokens(tokens, context, partials, template);
	  };

	  /**
	   * Low-level method that renders the given array of `tokens` using
	   * the given `context` and `partials`.
	   *
	   * Note: The `originalTemplate` is only ever used to extract the portion
	   * of the original template that was contained in a higher-order section.
	   * If the template doesn't use higher-order sections, this argument may
	   * be omitted.
	   */
	  Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate) {
	    var buffer = '';

	    var token, symbol, value;
	    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
	      value = undefined;
	      token = tokens[i];
	      symbol = token[0];

	      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);else if (symbol === '&') value = this.unescapedValue(token, context);else if (symbol === 'name') value = this.escapedValue(token, context);else if (symbol === 'text') value = this.rawValue(token);

	      if (value !== undefined) buffer += value;
	    }

	    return buffer;
	  };

	  Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate) {
	    var self = this;
	    var buffer = '';
	    var value = context.lookup(token[1]);

	    // This function is used to render an arbitrary template
	    // in the current context by higher-order sections.
	    function subRender(template) {
	      return self.render(template, context, partials);
	    }

	    if (!value) return;

	    if (isArray(value)) {
	      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
	        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
	      }
	    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
	      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
	    } else if (isFunction(value)) {
	      if (typeof originalTemplate !== 'string') throw new Error('Cannot use higher-order sections without the original template');

	      // Extract the portion of the original template that the section contains.
	      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

	      if (value != null) buffer += value;
	    } else {
	      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
	    }
	    return buffer;
	  };

	  Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate) {
	    var value = context.lookup(token[1]);

	    // Use JavaScript's definition of falsy. Include empty arrays.
	    // See https://github.com/janl/mustache.js/issues/186
	    if (!value || isArray(value) && value.length === 0) return this.renderTokens(token[4], context, partials, originalTemplate);
	  };

	  Writer.prototype.renderPartial = function renderPartial(token, context, partials) {
	    if (!partials) return;

	    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
	    if (value != null) return this.renderTokens(this.parse(value), context, partials, value);
	  };

	  Writer.prototype.unescapedValue = function unescapedValue(token, context) {
	    var value = context.lookup(token[1]);
	    if (value != null) return value;
	  };

	  Writer.prototype.escapedValue = function escapedValue(token, context) {
	    var value = context.lookup(token[1]);
	    if (value != null) return mustache.escape(value);
	  };

	  Writer.prototype.rawValue = function rawValue(token) {
	    return token[1];
	  };

	  mustache.name = 'mustache.js';
	  mustache.version = '2.1.3';
	  mustache.tags = ['{{', '}}'];

	  // All high-level mustache.* functions use this writer.
	  var defaultWriter = new Writer();

	  /**
	   * Clears all cached templates in the default writer.
	   */
	  mustache.clearCache = function clearCache() {
	    return defaultWriter.clearCache();
	  };

	  /**
	   * Parses and caches the given template in the default writer and returns the
	   * array of tokens it contains. Doing this ahead of time avoids the need to
	   * parse templates on the fly as they are rendered.
	   */
	  mustache.parse = function parse(template, tags) {
	    return defaultWriter.parse(template, tags);
	  };

	  /**
	   * Renders the `template` with the given `view` and `partials` using the
	   * default writer.
	   */
	  mustache.render = function render(template, view, partials) {
	    if (typeof template !== 'string') {
	      throw new TypeError('Invalid template! Template should be a "string" ' + 'but "' + typeStr(template) + '" was given as the first ' + 'argument for mustache#render(template, view, partials)');
	    }

	    return defaultWriter.render(template, view, partials);
	  };

	  // This is here for backwards compatibility with 0.4.x.,
	  /*eslint-disable */ // eslint wants camel cased function name
	  mustache.to_html = function to_html(template, view, partials, send) {
	    /*eslint-enable*/

	    var result = mustache.render(template, view, partials);

	    if (isFunction(send)) {
	      send(result);
	    } else {
	      return result;
	    }
	  };

	  // Export the escaping function so that the user may override it.
	  // See https://github.com/janl/mustache.js/issues/244
	  mustache.escape = escapeHtml;

	  // Export these mainly for testing, but also for advanced usage.
	  mustache.Scanner = Scanner;
	  mustache.Context = Context;
	  mustache.Writer = Writer;
	});

/***/ }
/******/ ]);